#!/usr/bin/env python3

import sounddevice as sd
import numpy as np
import whisper
import queue
import threading
import subprocess
import sys
import argparse
import os
from pynput import keyboard
from pynput.keyboard import Controller as KeyboardController
import time
import logging
from datetime import datetime

# Configuration
SAMPLE_RATE = 16000
BUFFER_SIZE = 1024
DEFAULT_HOTKEY = '<home>'  # Home key (XF86HomePage)
LOG_FILE = os.path.expanduser('~/dictate.log')
PID_FILE = os.path.expanduser('~/dictate.pid')

# Global state
audio_queue = queue.Queue()
is_recording = False
recording_lock = threading.Lock()
stop_flag = threading.Event()
model = None
use_notifications = True
auto_paste = True
append_enter_cr = True
kbd_controller = None
target_window_id = None
logger = None
last_activity = None
health_check_enabled = True

def check_single_instance():
    """Check if another instance is running and kill it if necessary."""
    if os.path.exists(PID_FILE):
        try:
            with open(PID_FILE, 'r') as f:
                old_pid = int(f.read().strip())

            # Check if process is still running
            try:
                os.kill(old_pid, 0)  # Signal 0 just checks if process exists
                # Process exists, kill it
                print(f"Found existing dictate process (PID {old_pid}), stopping it...")
                os.kill(old_pid, 15)  # SIGTERM
                time.sleep(0.5)

                # Check if it's still running, force kill if needed
                try:
                    os.kill(old_pid, 0)
                    print(f"Process didn't stop, force killing...")
                    os.kill(old_pid, 9)  # SIGKILL
                    time.sleep(0.3)
                except OSError:
                    pass  # Process is gone

                print(f"Previous instance stopped.")
            except OSError:
                # Process doesn't exist, just clean up stale PID file
                pass
        except (ValueError, IOError):
            # Invalid PID file, ignore
            pass

    # Write our PID
    with open(PID_FILE, 'w') as f:
        f.write(str(os.getpid()))

def setup_logging():
    """Setup logging to both file and console."""
    global logger
    logger = logging.getLogger('dictate')
    logger.setLevel(logging.DEBUG)

    # File handler with detailed logs
    fh = logging.FileHandler(LOG_FILE)
    fh.setLevel(logging.DEBUG)
    fh.setFormatter(logging.Formatter(
        '%(asctime)s [%(levelname)s] %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    ))

    # Console handler with minimal logs
    ch = logging.StreamHandler()
    ch.setLevel(logging.INFO)
    ch.setFormatter(logging.Formatter('%(message)s'))

    logger.addHandler(fh)
    logger.addHandler(ch)

    logger.info("=" * 60)
    logger.info("Dictate started")
    logger.info("=" * 60)

def notify(title, message, urgency="normal"):
    """Send desktop notification using notify-send."""
    if not use_notifications:
        return
    try:
        subprocess.run(['notify-send', '-u', urgency, title, message],
                      timeout=1, stderr=subprocess.DEVNULL)
    except:
        pass

def paste_text(text):
    """Type or paste text into focused window."""
    global target_window_id

    try:
        # Wait to ensure clipboard is fully updated
        time.sleep(0.3)

        # Use the window captured at recording start
        window_id = target_window_id
        if not window_id:
            # Fallback: get current window
            try:
                result = subprocess.run(['xdotool', 'getwindowfocus'],
                                      capture_output=True,
                                      timeout=2)
                window_id = result.stdout.decode().strip()
            except:
                window_id = None

        # Try xdotool type (directly types the text, more reliable than paste)
        if window_id:
            try:
                # Focus the window first
                subprocess.run(['xdotool', 'windowfocus', '--sync', window_id],
                             capture_output=True,
                             timeout=2)
                time.sleep(0.2)

                # Directly type the text
                result = subprocess.run(['xdotool', 'type', '--window', window_id, '--clearmodifiers', '--', text],
                                      capture_output=True,
                                      timeout=5)

                if result.returncode == 0:
                    time.sleep(0.2)
                    return True
            except (FileNotFoundError, subprocess.TimeoutExpired):
                pass

        # Fallback to pynput typing
        global kbd_controller
        if kbd_controller is None:
            kbd_controller = KeyboardController()
        time.sleep(0.2)
        kbd_controller.type(text)
        time.sleep(0.2)
        return True
    except Exception as e:
        print(f"âœ— Failed to insert text: {e}")
        return False

def audio_callback(indata, frames, time, status):
    """Callback for audio stream - captures audio when recording."""
    with recording_lock:
        if is_recording:
            audio_queue.put(indata.copy())

def transcribe_audio():
    """Thread to transcribe audio when recording stops and copy to clipboard."""
    global model

    try:
        while not stop_flag.is_set():
            # Wait until we have audio to process
            if audio_queue.qsize() == 0:
                stop_flag.wait(0.1)
                continue

            # Wait a bit to make sure recording has stopped and all audio is queued
            stop_flag.wait(0.3)

            with recording_lock:
                if is_recording:
                    continue

                # Collect all audio data
                audio_data = []
                while not audio_queue.empty():
                    try:
                        audio_data.append(audio_queue.get_nowait())
                    except queue.Empty:
                        break

                if len(audio_data) == 0:
                    continue

                audio_array = np.concatenate(audio_data)

            notify("Dictate", "Transcribing...")

            try:
                result = model.transcribe(audio_array.flatten(), language="en", fp16=False)
                text = result["text"].strip()

                # Append carriage return by default (unless disabled)
                if text and append_enter_cr:
                    text = text + "\r"
                    logger.debug(f"Appending carriage return to text")

                if text:
                    # Copy text to clipboard using xclip
                    try:
                        subprocess.run(['xclip', '-selection', 'clipboard'],
                                     input=text.encode(),
                                     check=True,
                                     timeout=2)
                        # Also copy to primary selection
                        subprocess.run(['xclip', '-selection', 'primary'],
                                     input=text.encode(),
                                     timeout=2)

                        # Auto-paste if enabled
                        if auto_paste:
                            if paste_text(text):
                                notify("Dictate", f"Inserted: {text[:50]}{'...' if len(text) > 50 else ''}")
                            else:
                                notify("Dictate", f"Copied: {text[:50]}{'...' if len(text) > 50 else ''}")
                        else:
                            notify("Dictate", f"Copied: {text[:50]}{'...' if len(text) > 50 else ''}")
                    except Exception as e:
                        notify("Dictate", "Failed to copy to clipboard", "critical")
                else:
                    notify("Dictate", "No speech detected", "low")
            except Exception as e:
                notify("Dictate", f"Error: {str(e)[:50]}", "critical")
    except Exception as e:
        pass
    finally:
        pass

def health_check_thread():
    """Monitor system health and log periodic heartbeats."""
    global last_activity

    try:
        while not stop_flag.is_set():
            stop_flag.wait(60)  # Check every minute
    except Exception as e:
        pass
    finally:
        pass

def on_press(key):
    """Handle global hotkey press."""
    global is_recording, target_window_id, last_activity

    try:
        last_activity = time.time()

        # Log all key presses for debugging
        logger.debug(f"Key pressed: {repr(key)} (type: {type(key).__name__})")
        if hasattr(key, 'vk'):
            logger.debug(f"  VK code: {hex(key.vk)}")

        # Home key detection - check multiple ways
        is_home_key = False

        # Method 1: Check by virtual key code (XF86HomePage)
        if hasattr(key, 'vk') and key.vk == 0x1008ff18:
            is_home_key = True
            logger.debug("  Home key detected by VK code")

        # Method 2: Check by string representation
        key_str = str(key)
        if 'home' in key_str.lower() or 'xf86homepage' in key_str.lower():
            is_home_key = True
            logger.debug("  Home key detected by string representation")

        # Method 3: Check if it's keyboard.Key.home
        try:
            if key == keyboard.Key.home:
                is_home_key = True
                logger.debug("  Home key detected by keyboard.Key.home")
        except:
            pass

        if is_home_key:
            with recording_lock:
                # Only start recording if not already recording (ignore key repeat)
                if not is_recording:
                    logger.info("HOME KEY PRESSED - Starting recording")
                    # Capture the focused window NOW, before recording starts
                    try:
                        result = subprocess.run(['xdotool', 'getwindowfocus'],
                                              capture_output=True,
                                              timeout=1)
                        target_window_id = result.stdout.decode().strip()
                    except:
                        target_window_id = None

                    is_recording = True
                    notify("Dictate", "Recording...", "low")
                else:
                    logger.debug("  Ignoring key repeat - already recording")
    except Exception as e:
        logger.error(f"Error in on_press: {e}")

def on_release(key):
    """Handle global hotkey release."""
    global is_recording, last_activity

    try:
        last_activity = time.time()

        # Log key release for debugging
        logger.debug(f"Key released: {repr(key)} (type: {type(key).__name__})")

        # Home key detection - check multiple ways (same as on_press)
        is_home_key = False

        # Method 1: Check by virtual key code (XF86HomePage)
        if hasattr(key, 'vk') and key.vk == 0x1008ff18:
            is_home_key = True
            logger.debug("  Home key detected by VK code")

        # Method 2: Check by string representation
        key_str = str(key)
        if 'home' in key_str.lower() or 'xf86homepage' in key_str.lower():
            is_home_key = True
            logger.debug("  Home key detected by string representation")

        # Method 3: Check if it's keyboard.Key.home
        try:
            if key == keyboard.Key.home:
                is_home_key = True
                logger.debug("  Home key detected by keyboard.Key.home")
        except:
            pass

        if is_home_key:
            logger.info("HOME KEY RELEASED - Stopping recording")
            with recording_lock:
                if is_recording:
                    is_recording = False

        # Note: ESC quit removed - use Ctrl+C in the terminal to quit
    except Exception as e:
        logger.error(f"Error in on_release: {e}")

def main():
    global model, use_notifications, auto_paste, append_enter_cr

    parser = argparse.ArgumentParser(
        description='Push-to-talk voice transcription with global hotkey',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  dictate                # Run with default settings (Home key)
  dictate --no-notify    # Run without desktop notifications
  dictate --no-paste     # Copy to clipboard only, don't auto-paste
  dictate --no-enter-cr  # Disable automatic carriage return (\\r)

Global Hotkey: Home key (press and hold to record, release to transcribe)
Default Behavior: Carriage return (\\r) is automatically appended to all text
Quit: Press Ctrl+C in the terminal
        """
    )
    parser.add_argument('--no-notify', action='store_true',
                       help='Disable desktop notifications')
    parser.add_argument('--no-paste', action='store_true',
                       help='Disable auto-paste (copy to clipboard only)')
    parser.add_argument('--no-enter-cr', action='store_true',
                       help='Disable automatic carriage return (\\r) appended to all text')
    parser.add_argument('--model', default='base',
                       choices=['tiny', 'base', 'small', 'medium', 'large'],
                       help='Whisper model size (default: base)')

    args = parser.parse_args()
    use_notifications = not args.no_notify
    auto_paste = not args.no_paste
    append_enter_cr = not args.no_enter_cr

    # Check for existing instance and kill it if found
    check_single_instance()

    # Setup logging
    setup_logging()

    # Load Whisper model
    print(f"Loading Whisper model ({args.model})...")
    model = whisper.load_model(args.model)
    print("Model loaded!")

    # Start the transcription thread
    transcription_thread = threading.Thread(target=transcribe_audio, daemon=True)
    transcription_thread.start()

    # Start health check thread
    health_thread = threading.Thread(target=health_check_thread, daemon=True)
    health_thread.start()

    # Start audio stream
    try:
        with sd.InputStream(callback=audio_callback, channels=1,
                           samplerate=SAMPLE_RATE, blocksize=BUFFER_SIZE):
            print("\nðŸŽ¤ Global Push-to-Talk Ready!")
            print("Hold HOME KEY to record (works system-wide)")
            if auto_paste:
                print("Auto-paste: ENABLED (use --no-paste to disable)")
            else:
                print("Auto-paste: DISABLED")
            if append_enter_cr:
                print("Auto carriage return: ENABLED - \\r appended to all text (use --no-enter-cr to disable)")
            else:
                print("Auto carriage return: DISABLED")
            print("Press Ctrl+C to quit\n")

            notify("Dictate", "Ready! Hold Home key to record", "low")

            # Start global keyboard listener
            try:
                with keyboard.Listener(on_press=on_press, on_release=on_release, suppress=False) as listener:
                    # Monitor the listener
                    while listener.running and not stop_flag.is_set():
                        stop_flag.wait(1)

                    listener.join()
            except Exception as e:
                raise

    except KeyboardInterrupt:
        print("\n\nStopping...")
    except Exception as e:
        notify("Dictate", f"Error: {e}", "critical")
        sys.exit(1)
    finally:
        stop_flag.set()
        time.sleep(0.5)  # Give threads time to finish

        # Clean up keyboard controller
        global kbd_controller
        if kbd_controller is not None:
            try:
                del kbd_controller
            except:
                pass

        # Clean up PID file
        try:
            if os.path.exists(PID_FILE):
                os.remove(PID_FILE)
        except:
            pass

        print("Stopped.")

if __name__ == "__main__":
    main()
